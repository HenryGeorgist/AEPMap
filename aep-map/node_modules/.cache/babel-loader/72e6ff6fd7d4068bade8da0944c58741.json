{"ast":null,"code":"import { METERS_PER_UNIT } from 'ol/proj/Units';\nimport Style from 'ol/style/Style';\nimport { createFeatureStyle, createLabelStyle } from './styles';\nimport { getFormattedLabel } from './formatters';\n/**\r\n * Map projection - used for labeling features\r\n * @type {import('ol/proj/Projection')}\r\n */\n\nlet mapProjection = null;\n/**\r\n * Set map projection used for labeling features\r\n * @param {import('ol/proj/Projection')} projection\r\n */\n\nexport const setMapProjection = projection => {\n  mapProjection = projection;\n};\n/**\r\n * Creates OpenLayers style function based on ESRI drawing info\r\n * @param {!String} layerUrl - ArcGIS REST URL to the layer\r\n * @return {Promise<Function>} function which styles features\r\n */\n\nexport const createStyleFunctionFromUrl = layerUrl => {\n  return fetch(`${layerUrl}?f=json`).then(responce => {\n    return responce.json();\n  }).then(esriStyleDefinition => {\n    return createStyleFunction(esriStyleDefinition);\n  });\n};\n/**\r\n * Creates OpenLayers style function based on ESRI drawing info\r\n * @param {!Object} esriLayerInfoJson\r\n * @param {import('./types').EsriRenderer} esriLayerInfoJson.renderer - see https://developers.arcgis.com/documentation/common-data-types/renderer-objects.htm for more info\r\n * @param {Array<import('./types').EsriLabelDefinition>} esriLayerInfoJson.labelingInfo - see https://developers.arcgis.com/documentation/common-data-types/labeling-objects.htm for more info\r\n * @return {Promise<Function>} function which styles features\r\n */\n\nexport const createStyleFunction = esriLayerInfoJson => {\n  return new Promise((yes, no) => {\n    let {\n      featureStyles,\n      labelStyles\n    } = readEsriStyleDefinitions(esriLayerInfoJson.drawingInfo);\n\n    for (let i = 0; i < featureStyles.length; i++) {\n      featureStyles[i].style = createFeatureStyle(featureStyles[i]);\n    }\n\n    for (let i = 0; i < labelStyles.length; i++) {\n      labelStyles[i].maxResolution = getMapResolutionFromScale(labelStyles[i].maxScale || 1000);\n      labelStyles[i].minResolution = getMapResolutionFromScale(labelStyles[i].minScale || 1);\n      labelStyles[i].label = labelStyles[i].text;\n      labelStyles[i].style = new Style({\n        text: createLabelStyle(labelStyles[i])\n      });\n    }\n\n    const styleFunction = (feature, resolution) => {\n      let styles = [];\n      const featureStyle = featureStyles.find(({\n        filters\n      }) => {\n        if (filters) {\n          return filters.every(({\n            field,\n            value\n          }) => {\n            const currentValue = feature.get(field);\n            const valuesIn = value.split(',').map(value => value.toString());\n            return valuesIn.indexOf(currentValue.toString()) > -1;\n          });\n        } else {\n          // will return the first style (default one)\n          return true;\n        }\n      });\n\n      if (featureStyle) {\n        styles.push(featureStyle.style);\n      }\n\n      const labelStyle = labelStyles.find(label => {\n        return label.maxResolution >= resolution && resolution >= label.minResolution;\n      });\n\n      if (labelStyle && labelStyle.style) {\n        const text = getFormattedLabel(feature, labelStyle.label);\n        labelStyle.style.getText().setText(text);\n        styles.push(labelStyle.style);\n      } // push labels!\n\n\n      return styles.length > 0 ? styles : null;\n    };\n\n    yes(styleFunction);\n  });\n};\n/**\r\n * Reads ESRI Style definitions into readable style definition\r\n * @param {!Object} esriLayerInfoJson\r\n * @param {import('./types').EsriRenderer} esriLayerInfoJson.renderer - see https://developers.arcgis.com/documentation/common-data-types/renderer-objects.htm for more info\r\n * @param {Array<import('./types').EsriLabelDefinition>} esriLayerInfoJson.labelingInfo - see https://developers.arcgis.com/documentation/common-data-types/labeling-objects.htm for more info\r\n * @return {Object} styles\r\n * @property {Array<import('./types').StyleType>} [styles.featureStyles]\r\n * @property {Array<import('./types').LabelType>} [styles.labelStyles]\r\n */\n\nexport const readEsriStyleDefinitions = ({\n  renderer,\n  labelingInfo\n}) => {\n  if (!renderer) throw 'renderer is not defined';\n  /**\r\n   * @type {Array<import(\"./types\").StyleType>}\r\n   */\n\n  let featureStyles = [];\n  /**\r\n   * @type {Array<import(\"./types\").LabelType>}\r\n   */\n\n  let labelStyles = labelingInfo ? readLabels(labelingInfo) : [];\n\n  switch (renderer.type) {\n    case 'simple':\n      featureStyles.push(readSymbol(renderer.symbol));\n      break;\n\n    case 'uniqueValue':\n      const uniqueFieldValues = filterUniqueValues(renderer.uniqueValueInfos, renderer.fieldDelimiter);\n\n      for (let i = 0; i < uniqueFieldValues.length; i++) {\n        const uniqueField = uniqueFieldValues[i];\n        /**\r\n         * @type {Array<import(\"./types\").FilterType>}\r\n         */\n\n        let filters = [];\n\n        if (renderer.field1) {\n          filters.push({\n            field: renderer.field1,\n            operator: 'in',\n            value: uniqueField.field1Values\n          });\n        }\n\n        if (renderer.field2) {\n          filters.push({\n            field: renderer.field2,\n            operator: 'in',\n            value: uniqueField.field2Values\n          });\n        }\n\n        if (renderer.field3) {\n          filters.push({\n            field: renderer.field3,\n            operator: 'in',\n            value: uniqueField.field3Values\n          });\n        }\n\n        const style = readSymbol(uniqueField.symbol);\n        featureStyles.push({\n          filters,\n          title: uniqueField.title,\n          ...style\n        });\n      }\n\n      if (renderer.defaultSymbol) {\n        featureStyles.push(readSymbol(renderer.defaultSymbol));\n      }\n\n      break;\n\n    default:\n      throw `\"Renderer type \"${renderer.type}\" is not implemented yet`;\n  }\n\n  return {\n    featureStyles,\n    labelStyles\n  };\n};\n/**\r\n * Reads label definitions for different map scales\r\n * @param {!Array<import('./types').EsriLabelDefinition>} labelingInfo\r\n * @return {Array<import('./types').LabelType>}\r\n */\n\nconst readLabels = labelingInfo => {\n  return labelingInfo.map(labelDefinition => {\n    let labelStyle = readSymbol(labelDefinition.symbol);\n    labelStyle.maxScale = labelDefinition.minScale || 1000;\n    labelStyle.minScale = labelDefinition.maxScale || 0;\n    labelStyle.text = labelDefinition.labelExpression.replace(/\\[/g, '{').replace(/\\]/g, '}').replace(/ CONCAT  NEWLINE  CONCAT /g, '\\n').replace(/ CONCAT /g, ' ');\n    return labelStyle;\n  });\n};\n/**\r\n * Convert ESRI style data to a readable style definition\r\n * @param {!esriPMS|esriSFS|esriSLS|esriSMS|esriTS} symbol - ESRI style definition\r\n * @param {!String} symbol.type - valid values are: `esriSMS`, `esriSLS`, `esriSFS`, `esriPMS` and `esriTS`\r\n * @return {import(\"./types\").StyleType}\r\n * @see https://developers.arcgis.com/documentation/common-data-types/symbol-objects.htm\r\n */\n\n\nconst readSymbol = symbol => {\n  switch (symbol.type) {\n    case 'esriSMS':\n      return {\n        circle: {\n          radius: symbol.size / 2,\n          fill: symbol.color ? {\n            color: `rgba(${symbol.color.join(',')})`\n          } : null,\n          stroke: symbol.outline ? {\n            color: `rgba(${symbol.outline.color.join(',')})`,\n            width: symbol.outline.width\n          } : null\n        }\n      };\n\n    case 'esriSLS':\n      return {\n        stroke: {\n          color: `rgba(${symbol.color.join(',')})`,\n          width: symbol.width\n        }\n      };\n\n    case 'esriSFS':\n      let style = readSymbol(symbol.outline);\n      style.fill = {\n        color: `rgba(${symbol.color.join(',')})`\n      };\n      return style;\n\n    case 'esriPMS':\n      return {\n        icon: {\n          src: `data:image/png;base64,${symbol.imageData}`,\n          rotation: symbol.angle\n        }\n      };\n\n    case 'esriTS':\n      return {\n        text: symbol.text,\n        font: symbol.font ? `${symbol.font.style} ${symbol.font.weight} ${symbol.font.size}pt ${symbol.font.family}` : '20px Calibri,sans-serif',\n        offsetX: symbol.xoffset + 20,\n        offsetY: symbol.yoffset - 10,\n        textAlign: symbol.horizontalAlignment,\n        textBaseline: symbol.verticalAlignment,\n        padding: [5, 5, 5, 5],\n        angle: symbol.angle,\n        fill: symbol.color ? {\n          color: `rgba(${symbol.color.join(',')})`\n        } : null,\n        stroke: symbol.haloColor ? {\n          color: `rgba(${symbol.haloColor.join(',')}`,\n          width: symbol.haloSize ? symbol.haloSize : null\n        } : null,\n        backgroundFill: symbol.backgroundColor ? {\n          fill: {\n            color: `rgba(${symbol.backgroundColor.join(',')})`\n          }\n        } : null,\n        backgroundStroke: symbol.borderLineColor ? {\n          stroke: {\n            color: `rgba(${symbol.borderLineColor.join(',')})`,\n            width: symbol.borderLineSize || null\n          }\n        } : null\n      };\n\n    default:\n      throw `Symbol type \"${symbol.type}\" is not implemented yet`;\n  }\n};\n/**\r\n * Filter styles based on field values\r\n *\r\n * @param {!Array<import('./types').EsriUniqueValueInfo>} styles - ESRI style definitions\r\n * @param {!String} delimiter - values delimiter\r\n * @return {Array<Object>}\r\n * @see https://developers.arcgis.com/documentation/common-data-types/renderer-objects.htm\r\n */\n\n\nconst filterUniqueValues = (styles, delimiter) => {\n  let uniqueSymbols = new Map();\n  styles.forEach(s => {\n    if (!uniqueSymbols.has(s.label)) {\n      uniqueSymbols.set(s.label, s.symbol);\n    }\n  });\n  let result = [];\n  uniqueSymbols.forEach((symbol, label) => {\n    const uniqueStyles = styles.filter(s => {\n      return s.label === label;\n    });\n    let field1Values = new Set();\n    let field2Values = new Set();\n    let field3Values = new Set();\n    uniqueStyles.forEach(s => {\n      field1Values.add(s.value.split(delimiter)[0]);\n      field2Values.add(s.value.split(delimiter)[1]);\n      field3Values.add(s.value.split(delimiter)[2]);\n    });\n    result.push({\n      title: label,\n      symbol: symbol,\n      field1Values: [...field1Values].join(),\n      field2Values: [...field2Values].join(),\n      field3Values: [...field3Values].join()\n    });\n  });\n  return result;\n};\n/**\r\n * @param {!Number} scale\r\n * @return {Number}\r\n */\n\n\nconst getMapResolutionFromScale = scale => {\n  if (mapProjection) {\n    const mpu = METERS_PER_UNIT[mapProjection.getUnits()];\n    return scale / (mpu * 39.37 * (25.4 / 0.28));\n  }\n};","map":{"version":3,"sources":["C:/Examples/aepmap/aep-map/node_modules/ol-esri-style/src/index.js"],"names":["METERS_PER_UNIT","Style","createFeatureStyle","createLabelStyle","getFormattedLabel","mapProjection","setMapProjection","projection","createStyleFunctionFromUrl","layerUrl","fetch","then","responce","json","esriStyleDefinition","createStyleFunction","esriLayerInfoJson","Promise","yes","no","featureStyles","labelStyles","readEsriStyleDefinitions","drawingInfo","i","length","style","maxResolution","getMapResolutionFromScale","maxScale","minResolution","minScale","label","text","styleFunction","feature","resolution","styles","featureStyle","find","filters","every","field","value","currentValue","get","valuesIn","split","map","toString","indexOf","push","labelStyle","getText","setText","renderer","labelingInfo","readLabels","type","readSymbol","symbol","uniqueFieldValues","filterUniqueValues","uniqueValueInfos","fieldDelimiter","uniqueField","field1","operator","field1Values","field2","field2Values","field3","field3Values","title","defaultSymbol","labelDefinition","labelExpression","replace","circle","radius","size","fill","color","join","stroke","outline","width","icon","src","imageData","rotation","angle","font","weight","family","offsetX","xoffset","offsetY","yoffset","textAlign","horizontalAlignment","textBaseline","verticalAlignment","padding","haloColor","haloSize","backgroundFill","backgroundColor","backgroundStroke","borderLineColor","borderLineSize","delimiter","uniqueSymbols","Map","forEach","s","has","set","result","uniqueStyles","filter","Set","add","scale","mpu","getUnits"],"mappings":"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","sourcesContent":["import { METERS_PER_UNIT } from 'ol/proj/Units';\r\nimport Style from 'ol/style/Style';\r\nimport { createFeatureStyle, createLabelStyle } from './styles';\r\nimport { getFormattedLabel } from './formatters';\r\n\r\n/**\r\n * Map projection - used for labeling features\r\n * @type {import('ol/proj/Projection')}\r\n */\r\nlet mapProjection = null;\r\n/**\r\n * Set map projection used for labeling features\r\n * @param {import('ol/proj/Projection')} projection\r\n */\r\nexport const setMapProjection = projection => {\r\n  mapProjection = projection;\r\n};\r\n\r\n/**\r\n * Creates OpenLayers style function based on ESRI drawing info\r\n * @param {!String} layerUrl - ArcGIS REST URL to the layer\r\n * @return {Promise<Function>} function which styles features\r\n */\r\nexport const createStyleFunctionFromUrl = layerUrl => {\r\n  return fetch(`${layerUrl}?f=json`)\r\n    .then(responce => {\r\n      return responce.json();\r\n    })\r\n    .then(esriStyleDefinition => {\r\n      return createStyleFunction(esriStyleDefinition);\r\n    });\r\n};\r\n\r\n/**\r\n * Creates OpenLayers style function based on ESRI drawing info\r\n * @param {!Object} esriLayerInfoJson\r\n * @param {import('./types').EsriRenderer} esriLayerInfoJson.renderer - see https://developers.arcgis.com/documentation/common-data-types/renderer-objects.htm for more info\r\n * @param {Array<import('./types').EsriLabelDefinition>} esriLayerInfoJson.labelingInfo - see https://developers.arcgis.com/documentation/common-data-types/labeling-objects.htm for more info\r\n * @return {Promise<Function>} function which styles features\r\n */\r\nexport const createStyleFunction = esriLayerInfoJson => {\r\n  return new Promise((yes, no) => {\r\n    let { featureStyles, labelStyles } = readEsriStyleDefinitions(esriLayerInfoJson.drawingInfo);\r\n    for (let i = 0; i < featureStyles.length; i++) {\r\n      featureStyles[i].style = createFeatureStyle(featureStyles[i]);\r\n    }\r\n    for (let i = 0; i < labelStyles.length; i++) {\r\n      labelStyles[i].maxResolution = getMapResolutionFromScale(labelStyles[i].maxScale || 1000);\r\n      labelStyles[i].minResolution = getMapResolutionFromScale(labelStyles[i].minScale || 1);\r\n      labelStyles[i].label = labelStyles[i].text;\r\n      labelStyles[i].style = new Style({ text: createLabelStyle(labelStyles[i]) });\r\n    }\r\n\r\n    const styleFunction = (feature, resolution) => {\r\n      let styles = [];\r\n      const featureStyle = featureStyles.find(({ filters }) => {\r\n        if (filters) {\r\n          return filters.every(({ field, value }) => {\r\n            const currentValue = feature.get(field);\r\n            const valuesIn = value.split(',').map(value => value.toString());\r\n            return valuesIn.indexOf(currentValue.toString()) > -1;\r\n          });\r\n        } else {\r\n          // will return the first style (default one)\r\n          return true;\r\n        }\r\n      });\r\n\r\n      if (featureStyle) {\r\n        styles.push(featureStyle.style);\r\n      }\r\n\r\n      const labelStyle = labelStyles.find(label => {\r\n        return label.maxResolution >= resolution && resolution >= label.minResolution;\r\n      });\r\n\r\n      if (labelStyle && labelStyle.style) {\r\n        const text = getFormattedLabel(feature, labelStyle.label);\r\n        labelStyle.style.getText().setText(text);\r\n        styles.push(labelStyle.style);\r\n      }\r\n\r\n      // push labels!\r\n\r\n      return styles.length > 0 ? styles : null;\r\n    };\r\n\r\n    yes(styleFunction);\r\n  });\r\n};\r\n\r\n/**\r\n * Reads ESRI Style definitions into readable style definition\r\n * @param {!Object} esriLayerInfoJson\r\n * @param {import('./types').EsriRenderer} esriLayerInfoJson.renderer - see https://developers.arcgis.com/documentation/common-data-types/renderer-objects.htm for more info\r\n * @param {Array<import('./types').EsriLabelDefinition>} esriLayerInfoJson.labelingInfo - see https://developers.arcgis.com/documentation/common-data-types/labeling-objects.htm for more info\r\n * @return {Object} styles\r\n * @property {Array<import('./types').StyleType>} [styles.featureStyles]\r\n * @property {Array<import('./types').LabelType>} [styles.labelStyles]\r\n */\r\nexport const readEsriStyleDefinitions = ({ renderer, labelingInfo }) => {\r\n  if (!renderer) throw 'renderer is not defined';\r\n\r\n  /**\r\n   * @type {Array<import(\"./types\").StyleType>}\r\n   */\r\n  let featureStyles = [];\r\n  /**\r\n   * @type {Array<import(\"./types\").LabelType>}\r\n   */\r\n  let labelStyles = labelingInfo ? readLabels(labelingInfo) : [];\r\n\r\n  switch (renderer.type) {\r\n    case 'simple':\r\n      featureStyles.push(readSymbol(renderer.symbol));\r\n      break;\r\n    case 'uniqueValue':\r\n      const uniqueFieldValues = filterUniqueValues(renderer.uniqueValueInfos, renderer.fieldDelimiter);\r\n\r\n      for (let i = 0; i < uniqueFieldValues.length; i++) {\r\n        const uniqueField = uniqueFieldValues[i];\r\n\r\n        /**\r\n         * @type {Array<import(\"./types\").FilterType>}\r\n         */\r\n        let filters = [];\r\n\r\n        if (renderer.field1) {\r\n          filters.push({\r\n            field: renderer.field1,\r\n            operator: 'in',\r\n            value: uniqueField.field1Values\r\n          });\r\n        }\r\n        if (renderer.field2) {\r\n          filters.push({\r\n            field: renderer.field2,\r\n            operator: 'in',\r\n            value: uniqueField.field2Values\r\n          });\r\n        }\r\n        if (renderer.field3) {\r\n          filters.push({\r\n            field: renderer.field3,\r\n            operator: 'in',\r\n            value: uniqueField.field3Values\r\n          });\r\n        }\r\n\r\n        const style = readSymbol(uniqueField.symbol);\r\n        featureStyles.push({\r\n          filters,\r\n          title: uniqueField.title,\r\n          ...style\r\n        });\r\n      }\r\n\r\n      if (renderer.defaultSymbol) {\r\n        featureStyles.push(readSymbol(renderer.defaultSymbol));\r\n      }\r\n\r\n      break;\r\n    default:\r\n      throw `\"Renderer type \"${renderer.type}\" is not implemented yet`;\r\n  }\r\n\r\n  return { featureStyles, labelStyles };\r\n};\r\n\r\n/**\r\n * Reads label definitions for different map scales\r\n * @param {!Array<import('./types').EsriLabelDefinition>} labelingInfo\r\n * @return {Array<import('./types').LabelType>}\r\n */\r\nconst readLabels = labelingInfo => {\r\n  return labelingInfo.map(labelDefinition => {\r\n    let labelStyle = readSymbol(labelDefinition.symbol);\r\n    labelStyle.maxScale = labelDefinition.minScale || 1000;\r\n    labelStyle.minScale = labelDefinition.maxScale || 0;\r\n    labelStyle.text = labelDefinition.labelExpression\r\n      .replace(/\\[/g, '{')\r\n      .replace(/\\]/g, '}')\r\n      .replace(/ CONCAT  NEWLINE  CONCAT /g, '\\n')\r\n      .replace(/ CONCAT /g, ' ');\r\n    return labelStyle;\r\n  });\r\n};\r\n\r\n/**\r\n * Convert ESRI style data to a readable style definition\r\n * @param {!esriPMS|esriSFS|esriSLS|esriSMS|esriTS} symbol - ESRI style definition\r\n * @param {!String} symbol.type - valid values are: `esriSMS`, `esriSLS`, `esriSFS`, `esriPMS` and `esriTS`\r\n * @return {import(\"./types\").StyleType}\r\n * @see https://developers.arcgis.com/documentation/common-data-types/symbol-objects.htm\r\n */\r\nconst readSymbol = symbol => {\r\n  switch (symbol.type) {\r\n    case 'esriSMS':\r\n      return {\r\n        circle: {\r\n          radius: symbol.size / 2,\r\n          fill: symbol.color\r\n            ? {\r\n                color: `rgba(${symbol.color.join(',')})`\r\n              }\r\n            : null,\r\n          stroke: symbol.outline\r\n            ? {\r\n                color: `rgba(${symbol.outline.color.join(',')})`,\r\n                width: symbol.outline.width\r\n              }\r\n            : null\r\n        }\r\n      };\r\n    case 'esriSLS':\r\n      return {\r\n        stroke: {\r\n          color: `rgba(${symbol.color.join(',')})`,\r\n          width: symbol.width\r\n        }\r\n      };\r\n    case 'esriSFS':\r\n      let style = readSymbol(symbol.outline);\r\n      style.fill = { color: `rgba(${symbol.color.join(',')})` };\r\n      return style;\r\n    case 'esriPMS':\r\n      return {\r\n        icon: {\r\n          src: `data:image/png;base64,${symbol.imageData}`,\r\n          rotation: symbol.angle\r\n        }\r\n      };\r\n    case 'esriTS':\r\n      return {\r\n        text: symbol.text,\r\n        font: symbol.font ? `${symbol.font.style} ${symbol.font.weight} ${symbol.font.size}pt ${symbol.font.family}` : '20px Calibri,sans-serif',\r\n        offsetX: symbol.xoffset + 20,\r\n        offsetY: symbol.yoffset - 10,\r\n        textAlign: symbol.horizontalAlignment,\r\n        textBaseline: symbol.verticalAlignment,\r\n        padding: [5, 5, 5, 5],\r\n        angle: symbol.angle,\r\n        fill: symbol.color ? { color: `rgba(${symbol.color.join(',')})` } : null,\r\n        stroke: symbol.haloColor\r\n          ? {\r\n              color: `rgba(${symbol.haloColor.join(',')}`,\r\n              width: symbol.haloSize ? symbol.haloSize : null\r\n            }\r\n          : null,\r\n        backgroundFill: symbol.backgroundColor\r\n          ? {\r\n              fill: { color: `rgba(${symbol.backgroundColor.join(',')})` }\r\n            }\r\n          : null,\r\n        backgroundStroke: symbol.borderLineColor\r\n          ? {\r\n              stroke: {\r\n                color: `rgba(${symbol.borderLineColor.join(',')})`,\r\n                width: symbol.borderLineSize || null\r\n              }\r\n            }\r\n          : null\r\n      };\r\n    default:\r\n      throw `Symbol type \"${symbol.type}\" is not implemented yet`;\r\n  }\r\n};\r\n\r\n/**\r\n * Filter styles based on field values\r\n *\r\n * @param {!Array<import('./types').EsriUniqueValueInfo>} styles - ESRI style definitions\r\n * @param {!String} delimiter - values delimiter\r\n * @return {Array<Object>}\r\n * @see https://developers.arcgis.com/documentation/common-data-types/renderer-objects.htm\r\n */\r\nconst filterUniqueValues = (styles, delimiter) => {\r\n  let uniqueSymbols = new Map();\r\n  styles.forEach(s => {\r\n    if (!uniqueSymbols.has(s.label)) {\r\n      uniqueSymbols.set(s.label, s.symbol);\r\n    }\r\n  });\r\n\r\n  let result = [];\r\n\r\n  uniqueSymbols.forEach((symbol, label) => {\r\n    const uniqueStyles = styles.filter(s => {\r\n      return s.label === label;\r\n    });\r\n    let field1Values = new Set();\r\n    let field2Values = new Set();\r\n    let field3Values = new Set();\r\n    uniqueStyles.forEach(s => {\r\n      field1Values.add(s.value.split(delimiter)[0]);\r\n      field2Values.add(s.value.split(delimiter)[1]);\r\n      field3Values.add(s.value.split(delimiter)[2]);\r\n    });\r\n\r\n    result.push({\r\n      title: label,\r\n      symbol: symbol,\r\n      field1Values: [...field1Values].join(),\r\n      field2Values: [...field2Values].join(),\r\n      field3Values: [...field3Values].join()\r\n    });\r\n  });\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * @param {!Number} scale\r\n * @return {Number}\r\n */\r\nconst getMapResolutionFromScale = scale => {\r\n  if (mapProjection) {\r\n    const mpu = METERS_PER_UNIT[mapProjection.getUnits()];\r\n    return scale / (mpu * 39.37 * (25.4 / 0.28));\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}