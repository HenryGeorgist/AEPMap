{"ast":null,"code":"const arrayIze = thing => {\n  return !thing || Array.isArray(thing) ? thing : [thing];\n};\n\nconst shouldSkipToken = (method, path, unless) => {\n  let skip = false; // check for method\n\n  if (unless && unless.method) {\n    const methods = arrayIze(unless.method);\n    if (methods.indexOf(method) !== -1) skip = true;\n  } // check for path\n\n\n  if (!skip) {\n    if (unless && unless.path) {\n      const paths = arrayIze(unless.path);\n      if (paths.indexOf(path) !== -1) skip = true;\n    }\n  } // check custom\n\n\n  if (!skip) {\n    if (unless && unless.custom) {\n      if (typeof unless.custom === \"function\") {\n        skip = custom({\n          method: method,\n          path: path\n        });\n      }\n    }\n  }\n\n  return skip;\n};\n\nexport default (opts => {\n  const defaults = {\n    name: \"api\",\n    root: \"\",\n    tokenSelector: \"selectAuthToken\",\n    unless: null\n  };\n  const config = Object.assign({}, defaults, opts);\n  const uCaseName = config.name.charAt(0).toUpperCase() + config.name.slice(1); // selectors\n\n  const selectRoot = `select${uCaseName}Root`;\n  const selectUnless = `select${uCaseName}Unless`;\n  const selectTokenSelector = `select${uCaseName}TokenSelector`;\n  return {\n    name: config.name,\n    getReducer: () => {\n      const initialData = {\n        root: config.root,\n        unless: config.unless,\n        tokenSelector: config.tokenSelector\n      };\n      return (state = initialData) => {\n        return state;\n      };\n    },\n    [selectRoot]: state => {\n      return state[config.name].root;\n    },\n    [selectUnless]: state => {\n      return state[config.name].unless;\n    },\n    [selectTokenSelector]: state => {\n      return state[config.name].tokenSelector;\n    },\n    getExtraArgs: store => {\n      return {\n        apiFetch: (path, options = {}) => {\n          const root = store[selectRoot]();\n          const unless = store[selectUnless]();\n          const tokenSelector = store[selectTokenSelector]();\n\n          if (!shouldSkipToken(options.method, path, unless)) {\n            const token = store[tokenSelector]();\n\n            if (!token) {\n              return null;\n            } else {\n              options.headers = {\n                Authorization: \"Bearer \" + token\n              };\n            }\n          }\n\n          return fetch(`${root}${path}`, options);\n        },\n        apiGet: (path, callback) => {\n          const root = store[selectRoot]();\n          const unless = store[selectUnless]();\n          const tokenSelector = store[selectTokenSelector]();\n          const options = {\n            method: \"GET\"\n          };\n\n          if (!shouldSkipToken(options.method, path, unless)) {\n            const token = store[tokenSelector]();\n\n            if (!token) {\n              return null;\n            } else {\n              options.headers = {\n                Authorization: \"Bearer \" + token\n              };\n            }\n          }\n\n          fetch(`${root}${path}`, options).then(response => {\n            if (!response.ok) {\n              throw new Error(`Request returned a ${response.status}`);\n            }\n\n            return response.json();\n          }).then(json => {\n            if (callback && typeof callback === \"function\") callback(null, json);\n          }).catch(err => {\n            callback(err);\n          });\n        },\n        apiPut: (path, payload, callback) => {\n          const root = store[selectRoot]();\n          const unless = store[selectUnless]();\n          const tokenSelector = store[selectTokenSelector]();\n          const options = {\n            method: \"PUT\",\n            headers: {\n              \"Content-Type\": \"application/json\"\n            }\n          };\n\n          if (!shouldSkipToken(options.method, path, unless)) {\n            const token = store[tokenSelector]();\n\n            if (!token) {\n              return null;\n            } else {\n              options.headers = { ...options.headers,\n                Authorization: \"Bearer \" + token\n              };\n            }\n          }\n\n          if (payload) {\n            options.body = JSON.stringify(payload);\n          }\n\n          fetch(`${root}${path}`, options).then(response => {\n            if (!response.ok) {\n              throw new Error(`Request returned a ${response.status}`);\n            }\n\n            return response.json();\n          }).then(json => {\n            if (callback && typeof callback === \"function\") callback(null, json);\n          }).catch(err => {\n            callback(err);\n          });\n        },\n        apiPost: (path, payload, callback) => {\n          const root = store[selectRoot]();\n          const unless = store[selectUnless]();\n          const tokenSelector = store[selectTokenSelector]();\n          const options = {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\"\n            }\n          };\n\n          if (!shouldSkipToken(options.method, path, unless)) {\n            const token = store[tokenSelector]();\n\n            if (!token) {\n              return null;\n            } else {\n              options.headers = { ...options.headers,\n                Authorization: \"Bearer \" + token\n              };\n            }\n          }\n\n          if (payload) {\n            options.body = JSON.stringify(payload);\n          }\n\n          fetch(`${root}${path}`, options).then(response => {\n            if (!response.ok) {\n              throw new Error(`Request returned a ${response.status}`);\n            }\n\n            return response.json();\n          }).then(json => {\n            if (callback && typeof callback === \"function\") callback(null, json);\n          }).catch(err => {\n            callback(err);\n          });\n        },\n        apiDelete: (path, callback) => {\n          const root = store[selectRoot]();\n          const unless = store[selectUnless]();\n          const tokenSelector = store[selectTokenSelector]();\n          const options = {\n            method: \"DELETE\"\n          };\n\n          if (!shouldSkipToken(options.method, path, unless)) {\n            const token = store[tokenSelector]();\n\n            if (!token) {\n              return null;\n            } else {\n              options.headers = {\n                Authorization: \"Bearer \" + token\n              };\n            }\n          }\n\n          fetch(`${root}${path}`, options).then(response => {\n            if (!response.ok) {\n              throw new Error(`Request returned a ${response.status}`);\n            }\n\n            return response.json();\n          }).then(json => {\n            if (callback && typeof callback === \"function\") callback(null, json);\n          }).catch(err => {\n            callback(err);\n          });\n        }\n      };\n    }\n  };\n});","map":{"version":3,"sources":["C:/Examples/aepmap/aep-map/node_modules/@corpsmap/create-jwt-api-bundle/index.js"],"names":["arrayIze","thing","Array","isArray","shouldSkipToken","method","path","unless","skip","methods","indexOf","paths","custom","opts","defaults","name","root","tokenSelector","config","Object","assign","uCaseName","charAt","toUpperCase","slice","selectRoot","selectUnless","selectTokenSelector","getReducer","initialData","state","getExtraArgs","store","apiFetch","options","token","headers","Authorization","fetch","apiGet","callback","then","response","ok","Error","status","json","catch","err","apiPut","payload","body","JSON","stringify","apiPost","apiDelete"],"mappings":"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","sourcesContent":["const arrayIze = (thing) => {\n  return !thing || Array.isArray(thing) ? thing : [thing];\n};\n\nconst shouldSkipToken = (method, path, unless) => {\n  let skip = false;\n  // check for method\n  if (unless && unless.method) {\n    const methods = arrayIze(unless.method);\n    if (methods.indexOf(method) !== -1) skip = true;\n  }\n\n  // check for path\n  if (!skip) {\n    if (unless && unless.path) {\n      const paths = arrayIze(unless.path);\n      if (paths.indexOf(path) !== -1) skip = true;\n    }\n  }\n\n  // check custom\n  if (!skip) {\n    if (unless && unless.custom) {\n      if (typeof unless.custom === \"function\") {\n        skip = custom({ method: method, path: path });\n      }\n    }\n  }\n\n  return skip;\n};\n\nexport default (opts) => {\n  const defaults = {\n    name: \"api\",\n    root: \"\",\n    tokenSelector: \"selectAuthToken\",\n    unless: null,\n  };\n\n  const config = Object.assign({}, defaults, opts);\n\n  const uCaseName = config.name.charAt(0).toUpperCase() + config.name.slice(1);\n\n  // selectors\n  const selectRoot = `select${uCaseName}Root`;\n  const selectUnless = `select${uCaseName}Unless`;\n  const selectTokenSelector = `select${uCaseName}TokenSelector`;\n\n  return {\n    name: config.name,\n\n    getReducer: () => {\n      const initialData = {\n        root: config.root,\n        unless: config.unless,\n        tokenSelector: config.tokenSelector,\n      };\n\n      return (state = initialData) => {\n        return state;\n      };\n    },\n\n    [selectRoot]: (state) => {\n      return state[config.name].root;\n    },\n\n    [selectUnless]: (state) => {\n      return state[config.name].unless;\n    },\n\n    [selectTokenSelector]: (state) => {\n      return state[config.name].tokenSelector;\n    },\n\n    getExtraArgs: (store) => {\n      return {\n        apiFetch: (path, options = {}) => {\n          const root = store[selectRoot]();\n          const unless = store[selectUnless]();\n          const tokenSelector = store[selectTokenSelector]();\n          if (!shouldSkipToken(options.method, path, unless)) {\n            const token = store[tokenSelector]();\n            if (!token) {\n              return null;\n            } else {\n              options.headers = {\n                Authorization: \"Bearer \" + token,\n              };\n            }\n          }\n          return fetch(`${root}${path}`, options);\n        },\n\n        apiGet: (path, callback) => {\n          const root = store[selectRoot]();\n          const unless = store[selectUnless]();\n          const tokenSelector = store[selectTokenSelector]();\n          const options = {\n            method: \"GET\",\n          };\n          if (!shouldSkipToken(options.method, path, unless)) {\n            const token = store[tokenSelector]();\n            if (!token) {\n              return null;\n            } else {\n              options.headers = {\n                Authorization: \"Bearer \" + token,\n              };\n            }\n          }\n          fetch(`${root}${path}`, options)\n            .then((response) => {\n              if (!response.ok) {\n                throw new Error(`Request returned a ${response.status}`);\n              }\n              return response.json();\n            })\n            .then((json) => {\n              if (callback && typeof callback === \"function\")\n                callback(null, json);\n            })\n            .catch((err) => {\n              callback(err);\n            });\n        },\n\n        apiPut: (path, payload, callback) => {\n          const root = store[selectRoot]();\n          const unless = store[selectUnless]();\n          const tokenSelector = store[selectTokenSelector]();\n          const options = {\n            method: \"PUT\",\n            headers: {\n              \"Content-Type\": \"application/json\",\n            },\n          };\n          if (!shouldSkipToken(options.method, path, unless)) {\n            const token = store[tokenSelector]();\n            if (!token) {\n              return null;\n            } else {\n              options.headers = {\n                ...options.headers,\n                Authorization: \"Bearer \" + token,\n              };\n            }\n          }\n          if (payload) {\n            options.body = JSON.stringify(payload);\n          }\n          fetch(`${root}${path}`, options)\n            .then((response) => {\n              if (!response.ok) {\n                throw new Error(`Request returned a ${response.status}`);\n              }\n              return response.json();\n            })\n            .then((json) => {\n              if (callback && typeof callback === \"function\")\n                callback(null, json);\n            })\n            .catch((err) => {\n              callback(err);\n            });\n        },\n\n        apiPost: (path, payload, callback) => {\n          const root = store[selectRoot]();\n          const unless = store[selectUnless]();\n          const tokenSelector = store[selectTokenSelector]();\n          const options = {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\",\n            },\n          };\n          if (!shouldSkipToken(options.method, path, unless)) {\n            const token = store[tokenSelector]();\n            if (!token) {\n              return null;\n            } else {\n              options.headers = {\n                ...options.headers,\n                Authorization: \"Bearer \" + token,\n              };\n            }\n          }\n          if (payload) {\n            options.body = JSON.stringify(payload);\n          }\n          fetch(`${root}${path}`, options)\n            .then((response) => {\n              if (!response.ok) {\n                throw new Error(`Request returned a ${response.status}`);\n              }\n              return response.json();\n            })\n            .then((json) => {\n              if (callback && typeof callback === \"function\")\n                callback(null, json);\n            })\n            .catch((err) => {\n              callback(err);\n            });\n        },\n\n        apiDelete: (path, callback) => {\n          const root = store[selectRoot]();\n          const unless = store[selectUnless]();\n          const tokenSelector = store[selectTokenSelector]();\n          const options = {\n            method: \"DELETE\",\n          };\n          if (!shouldSkipToken(options.method, path, unless)) {\n            const token = store[tokenSelector]();\n            if (!token) {\n              return null;\n            } else {\n              options.headers = {\n                Authorization: \"Bearer \" + token,\n              };\n            }\n          }\n          fetch(`${root}${path}`, options)\n            .then((response) => {\n              if (!response.ok) {\n                throw new Error(`Request returned a ${response.status}`);\n              }\n              return response.json();\n            })\n            .then((json) => {\n              if (callback && typeof callback === \"function\")\n                callback(null, json);\n            })\n            .catch((err) => {\n              callback(err);\n            });\n        },\n      };\n    },\n  };\n};\n"]},"metadata":{},"sourceType":"module"}